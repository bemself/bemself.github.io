<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="generator" content="TiddlyWiki" />
<meta name="tiddlywiki-version" content="5.1.22" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="mobile-web-app-capable" content="yes"/>
<meta name="format-detection" content="telephone=no">
<link id="faviconLink" rel="shortcut icon" href="favicon.ico">
<link rel="stylesheet" href="static.css">
<title>python/algs4-python-insertion-vs-selection-sort-algorithm: My Struggle — Life goes on...</title>
</head>
<body class="tc-body">

<section class="tc-story-river">
<p><div class="tc-tiddler-frame tc-tiddler-view-frame tc-tiddler-exists " data-tags="" data-tiddler-title="python/algs4-python-insertion-vs-selection-sort-algorithm"><div class="tc-tiddler-title"><div class="tc-titlebar"><span class="tc-tiddler-controls"><span class=" tc-reveal"><button aria-label="more" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fmore-tiddler-actions" title="More actions"></button><div class=" tc-reveal" hidden="true"></div></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal"><button aria-label="edit" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fedit" title="Edit this tiddler"></button></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal"><button aria-label="close" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fclose" title="Close this tiddler"></button></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span></span><span><span class="tc-tiddler-title-icon" style="fill:;"></span><h2 class="tc-title">python/algs4-python-insertion-vs-selection-sort-algorithm</h2></span></div><div class="tc-tiddler-info tc-popup-handle tc-reveal" hidden="true"></div></div><div class=" tc-reveal" hidden="true"></div>
<div class=" tc-reveal"><div class="tc-subtitle"><a class="tc-tiddlylink tc-tiddlylink-missing" href=".html"></a>26th July 2020</div></div><div class=" tc-reveal">
<div class="tc-tags-wrapper"></div>
</div>

<div class="tc-tiddler-body tc-reveal"><hr><p>title: Algorithm in Python - 插入排序算法和选择排序算法比较<br>edit: 2017-09-30<br>layout: post<br>categories:</p><ul><li><p>Python</p></li><li><p>算法<br>tags:</p></li><li><p>Python</p></li><li><p>算法<br>description: 《算法4》，用 Python 实现算法, 比较插入排序算法和选择排序算法。看过一些教材，普遍说插入排序算法比选择排序要快，实际上从上面的分析可以看出，其实二者的复杂度差不多，都是O(N平方)。后面的代码实现测试中也证实了这一点。</p></li></ul><hr><p><strong>排序算法列表电梯</strong>：</p><ul><li><p><strong>选择排序算法</strong>：详见 <a href="http://www.jianshu.com/p/93aba5441cc2" target="_blank">《算法4》2.1 - 选择排序算法(Selection Sort), Python实现</a></p></li><li><p><strong>插入排序算法(Insertion Sort)</strong>：详见<a href="http://www.jianshu.com/p/8c2ef0a86ab8" target="_blank">《算法4》2.1 - 插入排序算法(Insertion Sort), Python实现</a></p></li></ul><h1>插入排序算法和选择排序算法的复杂度分析:</h1><p>插入排序和选择排序都有两层循环，外循环遍历整个数组，内循环稍有区别：</p><ul><li><p>选择排序的内循环是遍历一组未排过序的数组，</p></li><li><p>插入排序的内循环是遍历一组已排过序的数组，</p></li></ul><p>在此基础上，进行比较或交换。看起来已经排序过的数组中进行插入会感觉性能要好一点，实际未必，这要看数组的具体情况，比如最坏情况下所有数组元素都得过一遍。</p><p>插入排序在插入的时候可以做交换操作，也可以不做交换。</p><p>改进插入排序算法可以使用二分法等，这里只探讨普通的插入排序。</p><p><strong>算法复杂度</strong></p><table><thead><tr><th>算法</th><th>最好情况</th><th>最坏情况</th></tr></thead><tbody><tr><td>选择排序</td><td>交换0次，比较n(n-1)/2次</td><td>交换N次</td></tr><tr><td>插入排序</td><td>交换0次，比较N-1次</td><td>交换n(n-1)/2次，比较n(n-1)/2次</td></tr></tbody></table><p>看过一些教材，普遍说插入排序算法比选择排序要快，实际上从上面的分析可以看出，其实二者的复杂度差不多，都是O(N平方)。后面的代码实现测试中也证实了这一点。</p><h1>插入排序和选择排序算法的比较：</h1><p>我们的python测试程序，考虑了不同大小的数组排序:</p><ul><li><p>1000</p></li><li><p>10000</p></li><li><p>20000</p></li></ul><p>每种又考虑了三种情况：</p><ul><li><p>随机生成数</p></li><li><p>最好情况：原数组已从小到大排好</p></li><li><p>最坏情况：原数组已从大到小排好</p></li></ul><p>并与python自带的sort方法作了比较。</p><p>完整代码如下：</p><pre><code>sizes = [
        1000,
        5000,
        10000
        ]

for size in sizes:
    # random generation of items to be sorted
    items = range
    print &quot;-&quot;*10 + &quot;sorting numbers&quot; + &quot;-&quot;*10
    items = []
    for i in range(0,size):
        items.append(random.randint(2,999))
    #print &quot;original items: %r&quot; % items
    # the worse case
    items_worse = range (size-1,-1,-1)
    # the best case
    items_best = range(0,size)

    to_be_sorted = [
            (&quot;random case&quot;,items),
            (&quot;worse case&quot;,items_worse),
            (&quot;best case&quot;,items_best)
            ]

    def duration(sort_method):    
        # calculate execution time for our selection sort method
        start = time.clock()
        sort_method.sort()
        end = time.clock()
        duration = end - start
        return duration

    for item in to_be_sorted:
        temp = copy.deepcopy(item) # for reversing use after a certain sort
        print &quot;-&quot;*10 + item[0] + &quot;-&quot;*10
        # calculate duration for insertion sort
        insertion_sort = InsertionSort(item[1])
        dinsertion = duration(insertion_sort)
        item = temp
        # calculate duration for selection sort    
        selection_sort = SelectionSort(item[1])
        dselection = duration(selection_sort)
        item = temp
        # calculate duration for python builtin sort
        dpython = duration(item[1])
        print &quot;%s: %ds&quot; % (&quot;insertion sort&quot;,dinsertion)
        print &quot;%s: %ds&quot; % (&quot;selection sort&quot;,dselection)
        print &quot;%s: %ds&quot; % (&quot;python built-in&quot;,dpython)
</code></pre><p>运行结果：</p><p>size = 1000：挺不错，都是毫秒级，但是看不出区别</p><pre><code>----------random case----------
item len: 1000
insertion sort: 0s
selection sort: 0s
python built-in: 0s
----------worse case----------
item len: 1000
insertion sort: 0s
selection sort: 0s
python built-in: 0s
----------best case----------
item len: 1000
insertion sort: 0s
selection sort: 0s
python built-in: 0s
</code></pre><p>size=10000: 有区别了，但是很少，1s差别。不过可以明显看出，最好情况下选择排序却用了6s多，最坏情况下，插入排序比选择排序慢了。</p><pre><code>----------random case----------
item len: 10000
insertion sort: 6s
selection sort: 7s
python built-in: 0s
----------worse case----------
item len: 10000
insertion sort: 8s
selection sort: 7s
python built-in: 0s
----------best case----------
item len: 10000
insertion sort: 0s
selection sort: 6s
python built-in: 0s
</code></pre><p>size=20000: 两种排序算法的耗时都明显提高了，但差别除了最好情况，差别仍然不大，基本说明二者的复杂度是差不多的。python自带的sort方法仍是毫秒级，过段时间等其他排序算法学了后研究下源码。</p><pre><code>----------random case----------
item len: 20000
insertion sort: 30s
selection sort: 33s
python built-in: 0s
----------worse case----------
item len: 20000
insertion sort: 39s
selection sort: 33s
python built-in: 0s
----------best case----------
item len: 20000
insertion sort: 0s
selection sort: 32s
python built-in: 0s
</code></pre></div>



</div>

</p>
</section>
</body>
</html>
