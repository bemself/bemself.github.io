{
    "tiddlers": {
        "$:/plugins/BurningTree/hammerwidgets/widgets/swipe.js": {
            "text": "/*\\\ntitle: $:/plugins/tiddlywiki/hammerjs/widgets/swipe.js\ntype: application/javascript\nmodule-type: widget\n\nactions triggered on swipe gestures\n\n\\*/\n(function (global) {\n\n\"use strict\";\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nif (typeof window !== 'undefined') {\n\tvar Hammer = require(\"$:/plugins/tiddlywiki/hammerjs/hammer.js\");\n}\n\nvar SwipeWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nSwipeWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nSwipeWidget.prototype.render = function(parent,nextSibling) {\n\tvar self = this;\n\tvar parentDomNode = parent;\n  \n\t// Compute attributes and execute state\n\tthis.computeAttributes();\n\tthis.execute();\n\n\tvar swipeDomNode = this.document.createElement(this.swipeTag);\n\tswipeDomNode.setAttribute(\"class\",this.swipeClass);\n\tparent.insertBefore(swipeDomNode,nextSibling);\n\tthis.domNodes.push(swipeDomNode);\n\tthis.renderChildren(swipeDomNode,null);\n\n\tvar hammer = new Hammer.Manager(swipeDomNode);\n\n\thammer.add(new Hammer.Swipe({\n\t\tevent: 'swipe',\n\t\tpointers: self.swipePointers,\n\t\tthreshold: self.swipeThreshold,\n\t\tvelocity: self.swipeVelocity,\n\t\tdirection: Hammer.DIRECTION_ALL\n\t}));\n\n\t// Tell Hammer it should listen for the swipe event\n\thammer.get('swipe');\n\n\thammer.on(\"swiperight\", function(e) {\n\t\te.preventDefault && e.preventDefault();\n\t\te.stopPropagation && e.stopPropagation();\n        $tw.wiki.setText(\"$:/state/swiping\",\"text\",undefined,\"yes\",null);\n\n\t\tif(self.swipeRightActions !== \"\") {\n\t\t\tself.invokeActionString(self.swipeRightActions,self,e);\n\t\t}\n\t\t$tw.wiki.deleteTiddler(\"$:/state/swiping\");\n\n\t\treturn true; // Action was invoked\n\t})\n\t.on(\"swipeleft\", function(e) {\n\t\te.preventDefault && e.preventDefault();\n\t\te.stopPropagation && e.stopPropagation();\n        $tw.wiki.setText(\"$:/state/swiping\",\"text\",undefined,\"yes\",null);\n\n\t\tif(self.swipeLeftActions !== \"\") {\n\t\t\tself.invokeActionString(self.swipeLeftActions,self,e);\n\t\t}\n\n\t\t$tw.wiki.deleteTiddler(\"$:/state/swiping\");\n\n\t\treturn true; // Action was invoked\n\t})\n\t.on(\"swipeup\", function(e) {\n\t\te.preventDefault && e.preventDefault();\n\t\te.stopPropagation && e.stopPropagation();\n        $tw.wiki.setText(\"$:/state/swiping\",\"text\",undefined,\"yes\",null);\n\n\t\tif(self.swipeUpActions !== \"\") {\n\t\t\tself.invokeActionString(self.swipeUpActions,self,e);\n\t\t}\n\n\t\t$tw.wiki.deleteTiddler(\"$:/state/swiping\");\n\n\t\treturn true; // Action was invoked\n\t})\n\t.on(\"swipedown\", function(e) {\n\t\te.preventDefault && e.preventDefault();\n\t\te.stopPropagation && e.stopPropagation();\n        $tw.wiki.setText(\"$:/state/swiping\",\"text\",undefined,\"yes\",null);\n\n\t\tif(self.swipeDownActions !== \"\") {\n\t\t\tself.invokeActionString(self.swipeDownActions,self,e);\n\t\t}\n\n\t\t$tw.wiki.deleteTiddler(\"$:/state/swiping\");\n\n\t\treturn true; // Action was invoked\n\t});\n};\n\n/*\nCompute the internal state of the widget\n*/\nSwipeWidget.prototype.execute = function() {\n\tthis.swipeClass = this.getAttribute(\"class\", \"tc-swipe-element\");\n\tthis.swipeTag = this.getAttribute(\"tag\", \"div\");\n\tthis.swipeLeftActions = this.getAttribute(\"leftactions\",\"\");\n\tthis.swipeUpActions = this.getAttribute(\"upactions\",\"\");\n\tthis.swipeRightActions = this.getAttribute(\"rightactions\",\"\");\n\tthis.swipeDownActions = this.getAttribute(\"downactions\",\"\");\n\tthis.swipeVelocity = parseFloat(this.getAttribute(\"velocity\", \"0.1\"));\n\tthis.swipePointers = parseInt(this.getAttribute(\"pointers\",\"1\"));\n\tthis.swipeThreshold = parseInt(this.getAttribute(\"threshold\",\"0\"));\n\tthis.makeChildWidgets();\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nSwipeWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(Object.keys(changedAttributes).length) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t}\n\treturn this.refreshChildren(changedTiddlers);\n};\n\nexports.swipe = SwipeWidget;\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/BurningTree/hammerwidgets/widgets/swipe.js",
            "module-type": "widget"
        },
        "$:/plugins/BurningTree/hammerwidgets/widgets/press.js": {
            "text": "/*\\\ntitle: $:/plugins/tiddlywiki/hammerjs/widgets/press.js\ntype: application/javascript\nmodule-type: widget\n\nactions triggered on press gestures\n\n\\*/\n(function (global) {\n\n\"use strict\";\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nif (typeof window !== 'undefined') {\n\tvar Hammer = require(\"$:/plugins/tiddlywiki/hammerjs/hammer.js\");\n}\n\nvar PressWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nPressWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nPressWidget.prototype.render = function(parent,nextSibling) {\n\tvar self = this;\n\tvar parentDomNode = parent;\n\t\n\t// Compute attributes and execute state\n\tthis.computeAttributes();\n\tthis.execute();\n\n\tvar pressDomNode = this.document.createElement(this.pressTag);\n\tpressDomNode.setAttribute(\"class\",this.pressClass);\n\tparent.insertBefore(pressDomNode,nextSibling);\n\tthis.domNodes.push(pressDomNode);\n\tthis.renderChildren(pressDomNode,null);\n\n\tvar hammer = new Hammer.Manager(pressDomNode);\n\n\t// Event Listener to cancel browser popup menu on long press\n\tpressDomNode.addEventListener('contextmenu', function(e) {\n\t\te.preventDefault && e.preventDefault();\n\t\te.stopPropagation && e.stopPropagation();\n\t\te.cancelBubble = true;\n\t\te.returnValue = false;\n\t\treturn false;\n\t});\n\n\thammer.add(new Hammer.Press({\n\t\tevent: 'press',\n\t\tpointers: self.pressPointers,\n\t\tthreshold: self.pressThreshold,\n\t\ttime: self.pressTime\n\t}));\n\t\n\thammer.get('press');\n\t\n\thammer.on('press', function(e) {\n\n\t\t$tw.wiki.setText(\"$:/state/pressing\",\"text\",undefined,\"yes\",null);\n\n\t\tif(self.pressStartActions) {\n\t\t\tself.invokeActionString(self.pressStartActions,self,e);\n\t\t}\n\t\treturn true;\n\t})\n\t.on('pressup', function(e) {\n\n\t\tif(self.pressEndActions) {\n\t\t\tself.invokeActionString(self.pressEndActions,self,e);\n\t\t}\n\n\t\t$tw.wiki.deleteTiddler(\"$:/state/pressing\");\n\n\t\treturn true;\n\t});\n};\n\n/*\nCompute the internal state of the widget\n*/\nPressWidget.prototype.execute = function() {\n\tthis.pressClass = this.getAttribute(\"class\", \"tc-press-element\");\n\tthis.pressTag = this.getAttribute(\"tag\", \"div\");\n\tthis.pressPointers = parseInt(this.getAttribute(\"pointers\",\"1\"));\n\tthis.pressTime = parseInt(this.getAttribute(\"time\",\"0\"));\n\tthis.pressThreshold = parseInt(this.getAttribute(\"threshold\",\"1000\"));\n\tthis.pressStartActions = this.getAttribute(\"startactions\",\"\");\n\tthis.pressEndActions = this.getAttribute(\"endactions\",\"\");\n\tthis.pressPopup = this.getAttribute(\"popup\");\n\tthis.makeChildWidgets();\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nPressWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(Object.keys(changedAttributes).length) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t}\n\treturn this.refreshChildren(changedTiddlers);\n};\n\nexports.press = PressWidget;\n})();",
            "type": "application/javascript",
            "title": "$:/plugins/BurningTree/hammerwidgets/widgets/press.js",
            "module-type": "widget"
        },
        "$:/plugins/BurningTree/hammerwidgets/widgets/tap.js": {
            "text": "/*\\\ntitle: $:/plugins/tiddlywiki/hammerjs/widgets/tap.js\ntype: application/javascript\nmodule-type: widget\n\nactions triggered on taps&clicks\n\n\\*/\n(function (global) {\n\n\"use strict\";\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nif (typeof window !== 'undefined') {\n\tvar Hammer = require(\"$:/plugins/tiddlywiki/hammerjs/hammer.js\");\n}\n\nvar TapWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nTapWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nTapWidget.prototype.render = function(parent,nextSibling) {\n\tvar self = this;\n\tvar parentDomNode = parent;\n\n\t// Compute attributes and execute state\n\tthis.computeAttributes();\n\tthis.execute();\n\t\n\tvar tapDomNode = this.document.createElement(this.tapTag);\n\ttapDomNode.setAttribute(\"class\",this.tapClass);\n\tparent.insertBefore(tapDomNode,nextSibling);\n\tthis.domNodes.push(tapDomNode);\n\tthis.renderChildren(tapDomNode,null);\n\n\tvar hammer = new Hammer.Manager(tapDomNode);\n\n\thammer.add(new Hammer.Tap({\n\t\tevent: 'usertap',\n\t\tpointers: self.tapPointers,\n\t\ttaps: self.tapCount,\n\t\tinterval: self.tapInterval,\n\t\ttime: self.tapTime,\n\t\tthreshold: self.tapThreshold,\n\t\tposThreshold: self.tapPosThreshold\n\t}));\n\n\thammer.get('usertap');\n\n\thammer.on('usertap', function(e) {\n\t\t$tw.wiki.setText(\"$:/state/tapping\",\"text\",undefined,\"yes\",null);\n\t\tif(self.tapActions) {\n\t\t\tself.invokeActionString(self.tapActions,self,e);\n\t\t}\n\n\t\t$tw.wiki.deleteTiddler(\"$:/state/tapping\");\n\t\treturn true; // Action was invoked\n\t});\n};\n\n/*\nCompute the internal state of the widget\n*/\nTapWidget.prototype.execute = function() {\n\tthis.tapClass = this.getAttribute(\"class\", \"tc-tap-element\");\n\tthis.tapTag = this.getAttribute(\"tag\", \"div\");\n\tthis.tapCount = parseInt(this.getAttribute(\"taps\",\"1\"));\n\tthis.tapPointers = parseInt(this.getAttribute(\"pointers\",\"1\"));\n\tthis.tapThreshold = parseInt(this.getAttribute(\"threshold\",\"100\"));\n\tthis.tapPosThreshold = parseInt(this.getAttribute(\"posthreshold\",\"200\"));\n\tthis.tapTime = parseInt(this.getAttribute(\"time\",\"250\"));\n\tthis.tapInterval = parseInt(this.getAttribute(\"interval\",\"300\"));\n\tthis.tapActions = this.getAttribute(\"actions\",\"\");\n\tthis.makeChildWidgets();\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nTapWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(Object.keys(changedAttributes).length) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t}\n\treturn this.refreshChildren(changedTiddlers);\n};\n\nexports.tap = TapWidget;\n})();",
            "type": "application/javascript",
            "title": "$:/plugins/BurningTree/hammerwidgets/widgets/tap.js",
            "module-type": "widget"
        },
        "$:/plugins/BurningTree/hammerwidgets/widgets/pan.js": {
            "text": "/*\\\ntitle: $:/plugins/tiddlywiki/hammerjs/widgets/pan.js\ntype: application/javascript\nmodule-type: widget\n\nactions triggered on pan gestures + event coordinates\n\n\\*/\n(function (global) {\n\n\"use strict\";\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nif (typeof window !== 'undefined') {\n\tvar Hammer = require(\"$:/plugins/tiddlywiki/hammerjs/hammer.js\");\n}\n\nvar PanWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nPanWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nPanWidget.prototype.render = function(parent,nextSibling) {\n\tvar self = this;\n\tvar parentDomNode = parent;\n\n\t// Compute attributes and execute state\n\tthis.computeAttributes();\n\tthis.execute();\n\n\tvar panDomNode = this.document.createElement(this.panTag);\n\tpanDomNode.setAttribute(\"class\",this.panClass);\n\tparent.insertBefore(panDomNode,nextSibling);\n\tthis.domNodes.push(panDomNode);\n\tthis.renderChildren(panDomNode,null);\n\n\tvar panStartValues = [];\n\tvar precision = this.userToFixed;\n\tvar panState = this.panStateTiddler;\n\n\tvar hammer = new Hammer.Manager(panDomNode);\n\n\thammer.add(new Hammer.Pan({\n\t\tevent: 'pan',\n\t\tpointers: self.panPointers,\n\t\tthreshold: self.panThreshold,\n\t\tdirection: Hammer.DIRECTION_ALL\n\t}));\n\n\thammer.get('pan');\n\n\tvar scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,\n\t\t  scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n\n\tvar startActions = null;\n\tvar domNodeRect = null;\n\tvar parentDomNodeRect = null;\n\n\tvar fieldStartNames = [ 'starting-x', 'starting-y', 'element-top', 'element-left', 'element-bottom', 'element-right', 'element-width', 'element-height', 'pointer-type', 'parent-x', 'parent-y', 'parent-classname', 'absolute-x', 'absolute-y'];\n\n\thammer.on('touchmove panstart panmove', function(e) {\n\t\t// Prevent default behaviour\n\t\te.preventDefault && e.preventDefault();\n\t\te.stopPropagation && e.stopPropagation();\n\n\t\t//Caching values, big performance impact\n\t\tvar pointerCenter = e.center,\n\t\t\tpointerCenterX = pointerCenter.x.toFixed(precision),\n\t\t\tpointerCenterY = pointerCenter.y.toFixed(precision),\n\t\t\tpointerDeltaX = e.deltaX.toFixed(precision),\n\t\t\tpointerDeltaY = e.deltaY.toFixed(precision),\n\t\t\tpanAltKey = e.changedPointers[0].altKey,\n\t\t\tpanCtrlKey = e.changedPointers[0].ctrlKey,\n\t\t\tpanShiftKey = e.changedPointers[0].shiftKey,\n\t\t\tpanMetaKey = e.changedPointers[0].metaKey,\n\t\t\tparentDomNodeClassName;\n\n\t\t// Set a \"dragging\" state tiddler - gets deleted when panning ends\n\t\t$tw.wiki.setText(\"$:/state/dragging\",\"text\",undefined,\"yes\",null);\n\n\t\t// Get the coordinates of the parent Dom Node\n\t\tif (parentDomNodeRect === null && parentDomNode !== undefined && parentDomNode.offsetParent !== undefined) {\n\t\t\tparentDomNodeRect = parentDomNode.offsetParent.getBoundingClientRect();\n\t\t\tparentDomNodeClassName = parentDomNode.offsetParent.className;\n\t\t}\n\n\t\t// Get the current coordinates of the element\n\t\tif (domNodeRect === null) {\n\t\t\tdomNodeRect = panDomNode.getBoundingClientRect();\n\t\t}\n\n\t\tif (self.panStartActions && startActions !== \"done\") {\n\t\t\tself.invokeActionString(self.panStartActions,self,e);\n\t\t\tstartActions = \"done\";\n\t\t}\n\n\t\t// Absolute coordinates of the pointer\n\t\tvar elementAbsoluteLeft = e.changedPointers[0].pageX; //(e.center.x + scrollLeft).toFixed(precision);\n\t\tvar elementAbsoluteTop = e.changedPointers[0].pageY; //(e.center.y + scrollTop).toFixed(precision);\n\t\t// Set values at pan-start only\n\t\tif (panStartValues.length === 0) {\n\t\t\tvar domNodeTop = domNodeRect.top.toFixed(precision),\n\t\t\t\tdomNodeLeft = domNodeRect.left.toFixed(precision),\n\t\t\t\tdomNodeRight = domNodeRect.right.toFixed(precision),\n\t\t\t\tdomNodeBottom = domNodeRect.bottom.toFixed(precision),\n\t\t\t\tdomNodeWidth = domNodeRect.width.toFixed(precision),\n\t\t\t\tdomNodeHeight = domNodeRect.height.toFixed(precision),\n\t\t\t\tdomNodeParentLeft = parentDomNodeRect.left.toFixed(precision) || \"undefined\",\n\t\t\t\tdomNodeParentTop = parentDomNodeRect.top.toFixed(precision) || \"undefined\";\n\n\t\t\tpanStartValues[0] = pointerCenterX;\n\t\t\tpanStartValues[1] = pointerCenterY;\n\t\t\tpanStartValues[2] = domNodeTop;\n\t\t\tpanStartValues[3] = domNodeLeft;\n\t\t\tpanStartValues[4] = domNodeBottom;\n\t\t\tpanStartValues[5] = domNodeRight;\n\t\t\tpanStartValues[6] = domNodeWidth;\n\t\t\tpanStartValues[7] = domNodeHeight;\n\t\t\tpanStartValues[8] = e.pointerType;\n\t\t\tpanStartValues[9] = domNodeParentLeft;\n\t\t\tpanStartValues[10] = domNodeParentTop;\n\t\t\tpanStartValues[11] = parentDomNodeClassName;\n\t\t\tpanStartValues[12] = elementAbsoluteLeft;\n\t\t\tpanStartValues[13] = elementAbsoluteTop;\n\n\t\t\tfor(var t = 0; t<panStartValues.length; t++){\n\t\t\t\tself.setField(panState,fieldStartNames[t],panStartValues[t]);\n\t\t\t}\n\t\t}\n\n\t\tself.setField(panState,'delta-x',pointerDeltaX);\n\t\tself.setField(panState,'delta-y',pointerDeltaY);\n\t\tself.setField(panState,'relative-x',pointerCenterX);\n\t\tself.setField(panState,'relative-y',pointerCenterY);\n\t\tself.setField(panState,'absolute-x',elementAbsoluteLeft);\n\t\tself.setField(panState,'absolute-y',elementAbsoluteTop);\n\t\tself.setField(panState,'alt-key',panAltKey);\n        self.setField(panState,'ctlr-key',panCtrlKey);\n        self.setField(panState,'shift-key',panShiftKey);\n\t\tself.setField(panState,'meta-key',panMetaKey);\n\t})\n\n\t.on('panend pancancel touchend mouseup', function(e) {\n\n\t\tstartActions = null;\n\t\tdomNodeRect = null;\n\t\tparentDomNodeRect = null;\n\t\tpanStartValues = [];\n\n\t\tif(self.panEndActions) {\n\t\t\tself.invokeActionString(self.panEndActions,self,e);\n\t\t}\n\n\t\t// Delete the \"dragging\" state tiddler\n\t\t$tw.wiki.deleteTiddler(\"$:/state/dragging\");\n\t\treturn true;\n\t});\n};\n\n\n/*\nSet the computed values in the state-tiddler fields\n*/\nPanWidget.prototype.setField = function(tiddler,field,value) {\n\t$tw.wiki.setText(tiddler,field,undefined,value,{ suppressTimestamp: true });\n};\n\n/*\nCompute the internal state of the widget\n*/\nPanWidget.prototype.execute = function() {\n\tthis.panClass = this.getAttribute(\"class\", \"tc-pan-element\");\n\tthis.panTag = this.getAttribute(\"tag\", \"div\");\n\tthis.panStateTiddler = this.getAttribute(\"state\",\"$:/state/pan\");\n\tthis.panPointers = parseInt(this.getAttribute(\"pointers\",\"1\"));\n\tthis.panThreshold = parseInt(this.getAttribute(\"threshold\",\"0\"));\n\tthis.userToFixed = parseInt(this.getAttribute(\"decimals\",\"0\"));\n\tthis.panStartActions = this.getAttribute(\"startactions\",\"\");\n\tthis.panEndActions = this.getAttribute(\"endactions\",\"\");\n\tthis.makeChildWidgets();\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nPanWidget.prototype.refresh = function(changedTiddlers) {\n\tvar self = this;\n\tvar changedAttributes = this.computeAttributes();\n\tif(Object.keys(changedAttributes).length) {\n\t\tself.refreshSelf();\n\t\treturn true;\n\t}\n\treturn this.refreshChildren(changedTiddlers);\n};\n\nexports.pan = PanWidget;\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/BurningTree/hammerwidgets/widgets/pan.js",
            "module-type": "widget"
        },
        "$:/plugins/BurningTree/hammerwidgets/widgets/pinch.js": {
            "text": "/*\\\ntitle: $:/plugins/tiddlywiki/hammerjs/widgets/pinch.js\ntype: application/javascript\nmodule-type: widget\n\nactions triggered on pinch gestures + event values\n\n\\*/\n(function (global) {\n\n\"use strict\";\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nif (typeof window !== 'undefined') {\n\tvar Hammer = require(\"$:/plugins/tiddlywiki/hammerjs/hammer.js\");\n}\n\nvar PinchWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nPinchWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nPinchWidget.prototype.render = function(parent,nextSibling) {\n\tvar self = this;\n\tvar parentDomNode = parent;\n\n\t// Compute attributes and execute state\n\tthis.computeAttributes();\n\tthis.execute();\n\n\tvar pinchDomNode = this.document.createElement(this.pinchTag);\n\tpinchDomNode.setAttribute(\"class\",this.pinchClass);\n\tparent.insertBefore(pinchDomNode,nextSibling);\n\tthis.domNodes.push(pinchDomNode);\n\tthis.renderChildren(pinchDomNode,null);\n\n\tvar hammer = new Hammer.Manager(pinchDomNode);\n\n\thammer.add(new Hammer.Pinch({\n\t\tevent: 'pinch',\n\t\tpointers: 2,\n\t\tthreshold: self.pinchThreshold\n\t}));\n\n\thammer.get('pinch').set({ enable: true });\n\n\tvar firstSet = null;\n\tvar startActions = null;\n\n\thammer.on('pinch pinchstart pinchmove', function(e) {\n\n\t\t$tw.wiki.setText(\"$:/state/pinching\",\"text\",undefined,\"yes\",null);\n\n\t\tvar rotationValue = e.rotation.toFixed(self.userToFixed);\n\t\tvar scaleValue = e.scale.toFixed(3);\n\n\t\tif(startActions !== \"done\") {\n\t\t\tself.invokeActionString(self.pinchStartActions,self,e);\n\t\t\tstartActions = \"done\";\n\t\t}\n\n\t\tif(firstSet !== \"done\") {\n\t\t\tself.setField(self.pinchStateTiddler,'rotation',rotationValue);\n\t\t\tself.setField(self.pinchStateTiddler,'scale',scaleValue);\n\t\t\tfirstSet = \"done\";\n\t\t}\n\n\t\tself.setField(self.pinchStateTiddler,'rotation',rotationValue);\n\t\tself.setField(self.pinchStateTiddler,'scale',scaleValue);\n\t})\n\t.on('pinchend pinchcancel touchend', function(e) {\n\t\te.stopPropagation && e.stopPropagation();\n\n\t\tif(self.pinchEndActions) {\n\t\t\tself.invokeActionString(self.pinchEndActions,self,e);\n\t\t}\n\n\t\tfirstSet = null;\n\t\tstartActions = null;\n\n\t\t$tw.wiki.deleteTiddler(\"$:/state/pinching\");\n\n\t\treturn true; // Action was invoked\n\t});\n};\n\n/*\nSet the computed values in the state-tiddler fields\n*/\nPinchWidget.prototype.setField = function(tiddler,field,value) {\n\t$tw.wiki.setText(tiddler,field,undefined,value,{ suppressTimestamp: true });\n};\n\n/*\nCompute the internal state of the widget\n*/\nPinchWidget.prototype.execute = function() {\n\tthis.pinchClass = this.getAttribute(\"class\", \"tc-pinch-div\");\n\tthis.pinchTag = this.getAttribute(\"tag\", \"div\");\n\tthis.userToFixed = parseInt(this.getAttribute(\"decimals\",\"0\"));\n\tthis.pinchThreshold = parseInt(this.getAttribute(\"threshold\",\"0\"));\n\tthis.pinchStateTiddler = this.getAttribute(\"statetiddler\",\"$:/state/pinch\");\n\tthis.pinchStartActions = this.getAttribute(\"startactions\",\"\");\n\tthis.pinchEndActions = this.getAttribute(\"endactions\",\"\");\n\tthis.makeChildWidgets();\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nPinchWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(Object.keys(changedAttributes).length) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t}\n\treturn this.refreshChildren(changedTiddlers);\n};\n\nexports.pinch = PinchWidget;\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/BurningTree/hammerwidgets/widgets/pinch.js",
            "module-type": "widget"
        },
        "$:/plugins/BurningTree/hammerwidgets/styles": {
            "title": "$:/plugins/BurningTree/hammerwidgets/styles",
            "tags": "$:/tags/Stylesheet",
            "text": "<$list filter=\"[[$:/state/dragging]!is[missing]]\">\n\niframe {\n    pointer-events: none;\n}\n\n</$list>\n\n"
        }
    }
}